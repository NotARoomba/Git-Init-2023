"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ChatGPTConversation_parentId, _ChatGPTConversation_clearanceToken, _ChatGPTConversation_bearerToken, _ChatGPTConversation_ua, _ChatGPTConversation_conversationId, _ChatGPTConversation_refreshBearerToken, _ChatGPTClient_instances, _ChatGPTClient_logger, _ChatGPTClient_clearanceToken, _ChatGPTClient_onRefreshCallback, _ChatGPTClient_sessionToken0, _ChatGPTClient_sessionToken1, _ChatGPTClient_refreshIntervalMinutes, _ChatGPTClient_lastTokenRefresh, _ChatGPTClient_bearerToken, _ChatGPTClient_ua, _ChatGPTClient_parseCookie, _ChatGPTClient_singleTokenRefresh, _ChatGPTClient_dualTokenRefresh, _ChatGPTClient_refreshBearerToken;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatGPTClient = exports.ChatGPTConversation = void 0;
const https_1 = __importDefault(require("https"));
const crypto_1 = __importDefault(require("crypto"));
const sseSubstringLength = 'data: '.length;
function getSetCookieValue(setCookieValue) {
    return setCookieValue.split('=')[1].split(';')[0];
}
function post(ua, url, data, clearanceToken, bearerToken) {
    return new Promise((resolve, reject) => {
        const req = https_1.default.request(url, {
            method: 'POST',
            headers: {
                accept: 'application/json',
                cookie: `cf_clearance=${clearanceToken}`,
                authorization: `Bearer ${bearerToken}`,
                'content-type': 'application/json',
                'user-agent': ua,
            },
        }, (res) => {
            res.setEncoding('utf-8');
            let streamData = '';
            if (res.statusCode !== 200) {
                return reject(new Error(res.statusMessage));
            }
            res.on('data', (c) => (streamData += c));
            res.on('end', () => resolve(streamData));
        });
        req.on('error', reject);
        req.write(JSON.stringify(data));
        req.end();
    });
}
function get(ua, url, clearanceToken, sessionToken0, sessionToken1) {
    return new Promise((resolve, reject) => {
        let cookie = '';
        if (sessionToken1) {
            cookie = `cf_clearance=${clearanceToken}; __Secure-next-auth.session-token.0=${sessionToken0}; __Secure-next-auth.session-token.1=${sessionToken1}`;
        }
        else {
            cookie = `cf_clearance=${clearanceToken}; __Secure-next-auth.session-token=${sessionToken0}`;
        }
        const req = https_1.default.get(url, {
            headers: {
                'cache-control': 'no-cache',
                cookie: cookie,
                referer: 'https://chat.openai.com/chat',
                'user-agent': ua,
            },
        }, (res) => {
            res.setEncoding('utf-8');
            let streamData = '';
            if (res.statusCode !== 200) {
                return reject(new Error(res.statusMessage));
            }
            res.on('data', (c) => (streamData += c));
            res.on('end', () => resolve({ body: streamData, headers: res.headers }));
        });
        req.on('error', reject);
    });
}
class ChatGPTConversation {
    constructor(ua, clearanceToken, bearerToken, refreshBearerToken, existingChatId) {
        _ChatGPTConversation_parentId.set(this, void 0);
        _ChatGPTConversation_clearanceToken.set(this, void 0);
        _ChatGPTConversation_bearerToken.set(this, void 0);
        _ChatGPTConversation_ua.set(this, void 0);
        _ChatGPTConversation_conversationId.set(this, void 0);
        _ChatGPTConversation_refreshBearerToken.set(this, void 0);
        __classPrivateFieldSet(this, _ChatGPTConversation_ua, ua, "f");
        __classPrivateFieldSet(this, _ChatGPTConversation_conversationId, existingChatId ?? null, "f");
        __classPrivateFieldSet(this, _ChatGPTConversation_clearanceToken, clearanceToken, "f");
        __classPrivateFieldSet(this, _ChatGPTConversation_bearerToken, bearerToken, "f");
        __classPrivateFieldSet(this, _ChatGPTConversation_parentId, crypto_1.default.randomUUID(), "f");
        __classPrivateFieldSet(this, _ChatGPTConversation_refreshBearerToken, refreshBearerToken, "f");
    }
    reset() {
        __classPrivateFieldSet(this, _ChatGPTConversation_parentId, crypto_1.default.randomUUID(), "f");
        __classPrivateFieldSet(this, _ChatGPTConversation_conversationId, null, "f");
    }
    /**
     *
     * @description conversationId can be null if the conversation has not been started yet with a call to chat first
     */
    getConversationId() {
        return __classPrivateFieldGet(this, _ChatGPTConversation_conversationId, "f");
    }
    async chat(message) {
        // refresh token, will return cached one if not expired
        __classPrivateFieldSet(this, _ChatGPTConversation_bearerToken, await __classPrivateFieldGet(this, _ChatGPTConversation_refreshBearerToken, "f").call(this), "f");
        const payload = {
            action: 'next',
            messages: [
                {
                    id: crypto_1.default.randomUUID(),
                    role: 'user',
                    content: { content_type: 'text', parts: [message] },
                },
            ],
            parent_message_id: __classPrivateFieldGet(this, _ChatGPTConversation_parentId, "f"),
            model: 'text-davinci-002-render',
        };
        if (__classPrivateFieldGet(this, _ChatGPTConversation_conversationId, "f")) {
            payload.conversation_id = __classPrivateFieldGet(this, _ChatGPTConversation_conversationId, "f");
        }
        const response = await post(__classPrivateFieldGet(this, _ChatGPTConversation_ua, "f"), 'https://chat.openai.com/backend-api/conversation', payload, __classPrivateFieldGet(this, _ChatGPTConversation_clearanceToken, "f"), __classPrivateFieldGet(this, _ChatGPTConversation_bearerToken, "f"));
        const sseMessages = response.split('\n').filter((s) => s.length);
        const result = JSON.parse(sseMessages[sseMessages.length - 2].substring(sseSubstringLength));
        __classPrivateFieldSet(this, _ChatGPTConversation_conversationId, result.conversation_id, "f");
        __classPrivateFieldSet(this, _ChatGPTConversation_parentId, result.message.id, "f");
        return result;
    }
}
exports.ChatGPTConversation = ChatGPTConversation;
_ChatGPTConversation_parentId = new WeakMap(), _ChatGPTConversation_clearanceToken = new WeakMap(), _ChatGPTConversation_bearerToken = new WeakMap(), _ChatGPTConversation_ua = new WeakMap(), _ChatGPTConversation_conversationId = new WeakMap(), _ChatGPTConversation_refreshBearerToken = new WeakMap();
class ChatGPTClient {
    /**
     *
     * @param {string} sessionToken0 __Secure-next-auth.session-token OR __Secure-next-auth.session-token.0
     * @param {string} sessionToken1 __Secure-next-auth.session-token.1
     * @param {number} refreshIntervalMinutes Defaults to 5 minutes
     */
    constructor(options, logger) {
        _ChatGPTClient_instances.add(this);
        _ChatGPTClient_logger.set(this, void 0);
        _ChatGPTClient_clearanceToken.set(this, void 0);
        _ChatGPTClient_onRefreshCallback.set(this, void 0);
        _ChatGPTClient_sessionToken0.set(this, void 0);
        _ChatGPTClient_sessionToken1.set(this, void 0);
        _ChatGPTClient_refreshIntervalMinutes.set(this, void 0);
        _ChatGPTClient_lastTokenRefresh.set(this, void 0);
        _ChatGPTClient_bearerToken.set(this, void 0);
        _ChatGPTClient_ua.set(this, void 0);
        __classPrivateFieldSet(this, _ChatGPTClient_ua, options.userAgent ??
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36', "f");
        __classPrivateFieldSet(this, _ChatGPTClient_clearanceToken, options.clearanceToken, "f");
        __classPrivateFieldSet(this, _ChatGPTClient_sessionToken0, options.sessionToken0, "f");
        __classPrivateFieldSet(this, _ChatGPTClient_sessionToken1, options.sessionToken1, "f");
        __classPrivateFieldSet(this, _ChatGPTClient_onRefreshCallback, options.onRefreshCallback, "f");
        __classPrivateFieldSet(this, _ChatGPTClient_refreshIntervalMinutes, options.refreshIntervalMinutes ?? 5, "f");
        __classPrivateFieldSet(this, _ChatGPTClient_logger, logger, "f");
    }
    getCurrentSession() {
        return {
            clearanceToken: __classPrivateFieldGet(this, _ChatGPTClient_clearanceToken, "f"),
            sessionToken0: __classPrivateFieldGet(this, _ChatGPTClient_sessionToken0, "f"),
            sessionToken1: __classPrivateFieldGet(this, _ChatGPTClient_sessionToken1, "f"),
        };
    }
    /**
     *
     * @description this will force a refresh to update bearer token
     */
    updateClientSession(clearanceToken, sessionToken0, sessionToken1) {
        __classPrivateFieldSet(this, _ChatGPTClient_clearanceToken, clearanceToken, "f");
        __classPrivateFieldSet(this, _ChatGPTClient_sessionToken0, sessionToken0, "f");
        __classPrivateFieldSet(this, _ChatGPTClient_sessionToken1, sessionToken1, "f");
        __classPrivateFieldGet(this, _ChatGPTClient_instances, "m", _ChatGPTClient_refreshBearerToken).call(this, true);
    }
    async startConversation(existingChatId) {
        await __classPrivateFieldGet(this, _ChatGPTClient_instances, "m", _ChatGPTClient_refreshBearerToken).call(this);
        if (!__classPrivateFieldGet(this, _ChatGPTClient_bearerToken, "f"))
            throw new Error('Session tokens are expired/invalid');
        return new ChatGPTConversation(__classPrivateFieldGet(this, _ChatGPTClient_ua, "f"), __classPrivateFieldGet(this, _ChatGPTClient_clearanceToken, "f"), __classPrivateFieldGet(this, _ChatGPTClient_bearerToken, "f"), __classPrivateFieldGet(this, _ChatGPTClient_instances, "m", _ChatGPTClient_refreshBearerToken).bind(this), existingChatId);
    }
}
exports.ChatGPTClient = ChatGPTClient;
_ChatGPTClient_logger = new WeakMap(), _ChatGPTClient_clearanceToken = new WeakMap(), _ChatGPTClient_onRefreshCallback = new WeakMap(), _ChatGPTClient_sessionToken0 = new WeakMap(), _ChatGPTClient_sessionToken1 = new WeakMap(), _ChatGPTClient_refreshIntervalMinutes = new WeakMap(), _ChatGPTClient_lastTokenRefresh = new WeakMap(), _ChatGPTClient_bearerToken = new WeakMap(), _ChatGPTClient_ua = new WeakMap(), _ChatGPTClient_instances = new WeakSet(), _ChatGPTClient_parseCookie = function _ChatGPTClient_parseCookie(response, refreshDate) {
    const cookies = response.headers['set-cookie'];
    const json = JSON.parse(response.body);
    if (!json.accessToken || !cookies)
        throw new Error('Failed to get new cookies, session expired/invalid');
    refreshDate.setMinutes(refreshDate.getMinutes() + __classPrivateFieldGet(this, _ChatGPTClient_refreshIntervalMinutes, "f"));
    const sessionTokens = cookies.filter((cookie) => cookie.startsWith('__Secure-next-auth.session-token'));
    return { sessionTokens, accessToken: json.accessToken };
}, _ChatGPTClient_singleTokenRefresh = async function _ChatGPTClient_singleTokenRefresh(refreshDate) {
    const response = await get(__classPrivateFieldGet(this, _ChatGPTClient_ua, "f"), 'https://chat.openai.com/api/auth/session', __classPrivateFieldGet(this, _ChatGPTClient_clearanceToken, "f"), __classPrivateFieldGet(this, _ChatGPTClient_sessionToken0, "f"));
    const { sessionTokens, accessToken } = __classPrivateFieldGet(this, _ChatGPTClient_instances, "m", _ChatGPTClient_parseCookie).call(this, response, refreshDate);
    if (sessionTokens.length !== 1)
        throw new Error('Failed to refresh single session-tokens from headers');
    __classPrivateFieldSet(this, _ChatGPTClient_lastTokenRefresh, refreshDate, "f");
    __classPrivateFieldSet(this, _ChatGPTClient_bearerToken, accessToken, "f");
    __classPrivateFieldSet(this, _ChatGPTClient_sessionToken0, getSetCookieValue(sessionTokens[0]), "f");
    __classPrivateFieldGet(this, _ChatGPTClient_logger, "f")?.call(this, 'ChatGPTClient: token refreshed at ' + refreshDate.toJSON());
    return accessToken;
}, _ChatGPTClient_dualTokenRefresh = async function _ChatGPTClient_dualTokenRefresh(refreshDate) {
    const response = await get(__classPrivateFieldGet(this, _ChatGPTClient_ua, "f"), 'https://chat.openai.com/api/auth/session', __classPrivateFieldGet(this, _ChatGPTClient_clearanceToken, "f"), __classPrivateFieldGet(this, _ChatGPTClient_sessionToken0, "f"), __classPrivateFieldGet(this, _ChatGPTClient_sessionToken1, "f"));
    const { sessionTokens, accessToken } = __classPrivateFieldGet(this, _ChatGPTClient_instances, "m", _ChatGPTClient_parseCookie).call(this, response, refreshDate);
    if (sessionTokens.length !== 2)
        throw new Error('Failed to refresh dual session-tokens from headers');
    __classPrivateFieldSet(this, _ChatGPTClient_lastTokenRefresh, refreshDate, "f");
    __classPrivateFieldSet(this, _ChatGPTClient_bearerToken, accessToken, "f");
    __classPrivateFieldSet(this, _ChatGPTClient_sessionToken0, getSetCookieValue(sessionTokens[0]), "f");
    __classPrivateFieldSet(this, _ChatGPTClient_sessionToken1, getSetCookieValue(sessionTokens[1]), "f");
    __classPrivateFieldGet(this, _ChatGPTClient_logger, "f")?.call(this, 'ChatGPTClient: token refreshed at ' + refreshDate.toJSON());
    return accessToken;
}, _ChatGPTClient_refreshBearerToken = async function _ChatGPTClient_refreshBearerToken(force) {
    const now = new Date();
    if (__classPrivateFieldGet(this, _ChatGPTClient_lastTokenRefresh, "f") &&
        now < __classPrivateFieldGet(this, _ChatGPTClient_lastTokenRefresh, "f") &&
        __classPrivateFieldGet(this, _ChatGPTClient_bearerToken, "f") &&
        !force)
        return __classPrivateFieldGet(this, _ChatGPTClient_bearerToken, "f");
    let token;
    if (__classPrivateFieldGet(this, _ChatGPTClient_sessionToken1, "f")) {
        token = await __classPrivateFieldGet(this, _ChatGPTClient_instances, "m", _ChatGPTClient_dualTokenRefresh).call(this, now);
    }
    else {
        token = await __classPrivateFieldGet(this, _ChatGPTClient_instances, "m", _ChatGPTClient_singleTokenRefresh).call(this, now);
    }
    __classPrivateFieldGet(this, _ChatGPTClient_onRefreshCallback, "f")?.call(this, {
        clearanceToken: __classPrivateFieldGet(this, _ChatGPTClient_clearanceToken, "f"),
        sessionToken0: __classPrivateFieldGet(this, _ChatGPTClient_sessionToken0, "f"),
        sessionToken1: __classPrivateFieldGet(this, _ChatGPTClient_sessionToken1, "f"),
    });
    return token;
};
